<!doctype html>
<title>Basic Emulator</title><!-- not BASIC! -->
<style>
    div {
        font-size: 12px;
        line-height: 16px;
    }
    body {
        background-color: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }
</style>

<script src="../build/libv86.js"></script>
<script>
"use strict";

// Helpers
function buf2hex(buffer) { // buffer is an ArrayBuffer or Uint8Array
    const u8 = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
    return [...u8].map(x => x.toString(16).padStart(2, '0')).join('');
}

// Little-endian integer helpers
const get_int = (n_bytes, array8, signed = false) => {
    // array8: Uint8Array or Array-like
    let v = 0;
    for (let i = 0; i < n_bytes; i++) {
        v |= (array8[i] & 0xff) << (8 * i);
    }
    if (signed) {
        const signBit = 1 << (n_bytes * 8 - 1);
        if (v & signBit) {
            // negative
            v = v - (1 << (n_bytes * 8));
        }
    }
    return v >>> 0;
};

// produce a Uint8Array of length n_bytes with little-endian contents of num
const to_int = (n_bytes, num) => {
    const out = new Uint8Array(n_bytes);
    for (let i = 0; i < n_bytes; i++) {
        out[i] = (num >> (8 * i)) & 0xff;
    }
    return out;
};

// Async iterator stream base
class ATStream {
    constructor({ delegate, acc, transform, observe }) {
        // delegate must be an async iterator (with next())
        this.delegate = delegate;
        this.acc = acc ?? (async ({ value }) => value);
        this.transform = transform;
        this.observe = observe;
        this.state = {};
        this.carry = [];
    }

    [Symbol.asyncIterator]() { return this; }

    async nextValueFromCarryOrDelegate() {
        if (this.carry.length > 0) {
            return { value: this.carry.shift(), done: false };
        }
        // delegate.next() expected to return { value, done }
        return await this.delegate.next();
    }

    async next_() {
        for (;;) {
            const ret = await this.nextValueFromCarryOrDelegate();
            if (ret.done) return ret;

            // acc may use this.state and may push to carry via carryFn
            const carryFn = v => this.carry.push(v);
            const accResult = await this.acc.call(this, {
                state: this.state,
                value: ret.value,
                carry: carryFn,
            });

            // if accResult undefined but carry has items, then continue to next loop iteration
            if (accResult === undefined) {
                // continue waiting for more data (or carried ones)
                if (this.carry.length > 0) {
                    // loop will pick up carry next iteration
                    continue;
                }
                // no value produced and no carry -> keep trying
                continue;
            }

            // produced value: reset state and/or return transformed value
            this.state = {};
            let valueToReturn = accResult;
            if (this.transform) {
                valueToReturn = await this.transform({ value: accResult });
            }
            return { value: valueToReturn, done: false };
        }
    }

    async next() {
        const ret = await this.next_();
        if (this.observe && !ret.done) {
            try { this.observe(ret); } catch (e) { console.error("observe error", e); }
        }
        return ret;
    }
}

// A callback-driven byte stream suitable for wiring emulator output into an async iterator
const NewCallbackByteStream = () => {
    let resolver = null;
    const queue = [];
    const pendingPromises = [];

    const pushValue = (v) => {
        if (pendingPromises.length > 0) {
            // resolve oldest pending promise
            const r = pendingPromises.shift();
            r({ value: v, done: false });
        } else {
            queue.push(v);
        }
    };

    const stream = {
        [Symbol.asyncIterator]() { return this; },
        async next() {
            if (queue.length > 0) {
                return { value: queue.shift(), done: false };
            }
            // no queued value, return a promise that'll be resolved when pushValue is called
            return await new Promise((resolve) => {
                pendingPromises.push(resolve);
            });
        }
    };

    // exposed listener used by external producers:
    stream.listener = (data) => {
        // coerce to Uint8Array
        const payload = (data instanceof Uint8Array) ? data : new Uint8Array(data);
        pushValue(payload);
    };

    return stream;
};

// Virtio framed stream: each frame is [4-byte little-endian length][payload...]
// Accepts a byte stream that yields Uint8Array chunks. Assembles frames and yields full payload Uint8Array.
const NewVirtioFrameStream = (byteStream) => {
    return new ATStream({
        delegate: byteStream,
        async acc({ value, carry }) {
            // value is a Uint8Array chunk
            if (!this.state.buffer) {
                if (value.length < 4) {
                    // not enough bytes to read size header; store partial header
                    const hdr = new Uint8Array(value.length);
                    hdr.set(value, 0);
                    this.state.partialHeader = hdr;
                    return;
                }
                // read size from first 4 bytes
                const size = get_int(4, value);
                if (size > 512 * (1024 ** 2)) {
                    throw new Error(`Way too much data! (${size} bytes)`);
                }
                // remainder after header
                const remainder = value.slice(4);
                this.state.buffer = new Uint8Array(size);
                this.state.index = 0;

                if (remainder.length > 0) {
                    // feed remainder back via carry so normal logic consumes it
                    carry(remainder);
                }
                return;
            }

            // we already have a target buffer
            const needed = this.state.buffer.length - this.state.index;
            const amount = Math.min(value.length, needed);
            this.state.buffer.set(value.slice(0, amount), this.state.index);
            this.state.index += amount;

            if (value.length > amount) {
                // extra bytes - pass them back via carry
                carry(value.slice(amount));
            }

            if (this.state.index === this.state.buffer.length) {
                const out = this.state.buffer;
                this.state.buffer = undefined;
                this.state.index = undefined;
                return out;
            }
            // otherwise wait for more chunks
        }
    });
};

// wisp types
const wisp_types = [
    {
        id: 3,
        label: 'CONTINUE',
        describe: ({ payload }) => `buffer: ${get_int(4, payload)}B`,
        getAttributes: ({ payload }) => ({ buffer_size: get_int(4, payload) })
    },
    {
        id: 5,
        label: 'INFO',
        describe: ({ payload }) => `v${payload[0]}.${payload[1]} ${buf2hex(payload.slice(2))}`,
        getAttributes: ({ payload }) => ({
            version_major: payload[0],
            version_minor: payload[1],
            extensions: payload.slice(2),
        })
    },
];

class WispPacket {
    static SEND = Symbol('SEND');
    static RECV = Symbol('RECV');

    constructor({ data, direction, extra }) {
        this.direction = direction;
        this.data_ = data instanceof Uint8Array ? data : new Uint8Array(data);
        this.extra = extra ?? {};
        this.types_ = {
            1: { label: 'CONNECT' },
            2: { label: 'DATA' },
            4: { label: 'CLOSE' },
        };
        for (const item of wisp_types) {
            this.types_[item.id] = item;
        }
    }

    get type() {
        const i_ = this.data_[0];
        return this.types_[i_] ?? { label: `UNKNOWN(${i_})` };
    }

    get attributes() {
        if (!this.type.getAttributes) return { ...this.extra };
        const attrs = this.type.getAttributes({ payload: this.data_.slice(5) });
        return Object.assign({}, attrs, this.extra);
    }

    toVirtioFrame() {
        const lenBytes = to_int(4, this.data_.length);
        const arry = new Uint8Array(this.data_.length + 4);
        arry.set(lenBytes, 0);
        arry.set(this.data_, 4);
        return arry;
    }

    describe() {
        const desc = this.type.describe?.({ payload: this.data_.slice(5) });
        return `${this.type.label}(${desc ?? '?'})`;
    }

    log() {
        const arrow =
            this.direction === this.constructor.SEND ? '->' :
            this.direction === this.constructor.RECV ? '<-' : '<>';
        console.groupCollapsed(`WISP ${arrow} ${this.describe()}`);
        const attrs = this.attributes;
        for (const k in attrs) {
            console.log(k, attrs[k]);
        }
        console.groupEnd();
    }

    reflect() {
        return new WispPacket({
            data: this.data_,
            direction:
                this.direction === this.constructor.SEND ? this.constructor.RECV :
                this.direction === this.constructor.RECV ? this.constructor.SEND :
                undefined,
            extra: { reflectedFrom: this },
        });
    }
}

for (const item of wisp_types) {
    WispPacket[item.label] = item;
}

const NewWispPacketStream = (frameStream) => {
    return new ATStream({
        delegate: frameStream,
        transform({ value }) {
            // value is a Uint8Array payload representing a wisp frame
            return new WispPacket({ data: value, direction: WispPacket.RECV });
        },
        observe({ value }) {
            try { value.log(); } catch (e) { console.error("wisp observe error", e); }
        }
    });
};

class WispClient {
    constructor({ packetStream, sendFn }) {
        this.packetStream = packetStream;
        this.sendFn = sendFn;
    }
    send(packet) {
        try { packet.log(); } catch (e) { /* ignore logging errors */ }
        this.sendFn(packet);
    }
}

window.onload = async function () {
    // load rootfs as ArrayBuffer
    const resp = await fetch('./image/build/x86images/rootfs.bin');
    const arrayBuffer = await resp.arrayBuffer();

    const emulator = window.emulator = new V86({
        wasm_path: "../build/v86.wasm",
        memory_size: 512 * 1024 * 1024,
        vga_memory_size: 2 * 1024 * 1024,
        screen_container: document.getElementById("screen_container"),
        bios: { url: "../bios/seabios.bin" },
        vga_bios: { url: "../bios/vgabios.bin" },
        initrd: { url: './image/build/x86images/boot/initramfs-lts' },
        bzimage: { url: './image/build/x86images/boot/vmlinuz-lts', async: false },
        cmdline: 'rw root=/dev/sda init=/sbin/init rootfstype=ext4',
        hda: { buffer: arrayBuffer, async: true },
        autostart: true,
        network_relay_url: "wisp://127.0.0.1:3000",
        virtio_console: true,
    });

    const byteStream = NewCallbackByteStream();
    // wire emulator output into our byte stream
    emulator.add_listener('virtio-console0-output-bytes', byteStream.listener);

    const virtioStream = NewVirtioFrameStream(byteStream);
    const wispStream = NewWispPacketStream(virtioStream);

    class PTYManager {
        constructor({ client }) {
            this.client = client;
        }
        init() { this.run_(); }

        async run_() {
            const handlers = {
                [WispPacket.INFO.id]: ({ packet }) => {
                    // reflect INFO packet back
                    this.client.send(packet.reflect());
                }
            };
            for await (const packet of this.client.packetStream) {
                try {
                    const typeId = packet.type?.id;
                    if (typeId !== undefined && handlers[typeId]) {
                        handlers[typeId]({ packet });
                    }
                } catch (e) {
                    console.error("handler error", e);
                }
            }
        }
    }

    const ptyMgr = new PTYManager({
        client: new WispClient({
            packetStream: wispStream,
            sendFn: packet => {
                emulator.bus.send("virtio-console0-input-bytes", packet.toVirtioFrame());
            }
        })
    });
    ptyMgr.init();
};
</script>

<!-- Screen -->
<div id="screen_container">
    <div style="white-space: pre; font: 14px monospace; line-height: 14px"></div>
    <canvas style="display: none"></canvas>
</div>
